"""
Contains code for ImageData class.
"""

# TODO - Dream - Add proper try-cath error checking everywhere and incorporate logging into it

# Import standard python packages
from cv2 import findContours, RETR_EXTERNAL, CHAIN_APPROX_NONE, contourArea, moments
from numpy import sum, uint8, array, frombuffer, reshape, append, savez, load
from rospy import Time
from cv_bridge import CvBridge, CvBridgeError
from os.path import exists
from os import mkdir, listdir
from datetime import date, datetime

# Import standard ROS packages
from sensor_msgs.msg import Image
from thyroid_ultrasound_imaging_support.Validation.date_stamp_str import date_stamp_str

# Import custom python packages
from thyroid_ultrasound_messages.msg import image_data_message
from thyroid_ultrasound_imaging_support.ImageData.single_line_representations import \
    create_single_line_simple_data, create_single_line_array_data, create_single_line_list_data, \
    create_single_line_time_stamp, rebuild_data, NEW_LINE

# Import custom ROS packages
from thyroid_ultrasound_imaging_support.ImageData.BridgeImageDataMessageConstants import *
from thyroid_ultrasound_imaging_support.ImageData.bridge_list_of_points_multi_array import \
    bridge_list_of_points_multi_array
from thyroid_ultrasound_imaging_support.ImageData.bridge_list_of_contours_multi_array import \
    bridge_list_of_contours_multi_array

# Define constants for bridging between the object and its string
IMAGE_DATA_OBJECT: str = 'image-data-object'
SIMPLE_DATA: str = 'simple-data'
TXT: str = '.txt'
NPZ: str = '.npz'
ARRAY_DATA: str = 'array-data'
IMAGE_TITLE: str = "image_title"
IMAGE_COLOR: str = "image_color"
IMAGE_SIZE_X: str = "image_size_x"
IMAGE_SIZE_Y: str = "image_size_y"
DS_IMAGE_SIZE_X: str = "ds_image_size_x"
DS_IMAGE_SIZE_Y: str = "ds_image_size_y"
DOWN_SAMPLING_RATE: str = "down_sampling_rate"
IMAGE_CROP_COORDINATES: str = "image_crop_coordinates"
SEGMENTATION_INITIALIZATION_MASK: str = "segmentation_initialization_mask"
ORIGINAL_IMAGE: str = "original_image"
CROPPED_IMAGE: str = "cropped_image"
COLORIZED_IMAGE: str = "colorized_image"
DOWN_SAMPLED_IMAGE: str = "down_sampled_image"
PRE_PROCESSED_IMAGE: str = "pre_processed_image"
IMAGE_MASK: str = "image_mask"
POST_PROCESSED_MASK: str = "post_processed_mask"
SURE_FOREGROUND_MASK: str = "sure_foreground_mask"
SURE_BACKGROUND_MASK: str = "sure_background_mask"
PROBABLE_FOREGROUND_MASK: str = "probable_foreground_mask"
CONTOURS_IN_IMAGE: str = "contours_in_image"
CONTOUR_CENTROIDS: str = "contour_centroids"
IMAGE_CAPTURE_TIME: str = "image_capture_time"


class ImageData:
    """
    A class for holding image data and its filtered components.

    Attributes
    ----------
    image_title:
        A title to display for the image
    image_color
        The color coding of the image according to custom constants

    image_size_x
        The original image size in the x direction
    image_size_y
        The original image size in the y direction

    ds_image_size_x
        The down-sampled image size in the x direction
    ds_image_size_y
        The down-sampled image size in the y direction
    down_sampling_rate
        The rate at which the original image was downsized
    image_crop_coordinates
        The coordinate pairs used to crop the original image

    segmentation_initialization_mask
        The mask to use to initialize the segmentation of the image.

    original_image
        The original image
    cropped_image
        The cropped version of the original image
    colorized_image
        The recolored version of the cropped image
    down_sampled_image
        The down-sampled version of the colorized image
    pre_processed_image
        The pre-processed version of the colorized image
    image_mask
        The binary mask generated by segmenting the pre-processed image
    post_processed_mask
        The post-processed version of the image mask
    sure_foreground_mask
        The binary mask generated by shrinking the regions of the expanded image mask
    sure_background_mask
        The binary mask generated by expanding the regions of the image mask and inverting the mask
    probable_foreground_mask
        The binary mask generated as the difference between the sure foreground mask and the sure background mask

    contours_in_image
        A list of contours found in the expanded image mask
    contour_centroids
        A list of centroids of the contours found in the image

    image_capture_time
        A timestamp of when the image was captured

    """

    def __init__(self, image_data: array = None,
                 image_color: int = None,
                 image_title: str = "",
                 image_capture_time: Time = None,
                 segmentation_initialization_mask: array = None,
                 image_data_msg: image_data_message = None,
                 image_data_location: str = None,
                 display_error_messages: bool = False):
        """
        Creates a new ImageData object.

        New ImageData objects can be built in two ways. First, with an array representing a 2D image. Second, with an
        ImageDataMessage object.

        Parameters
        ----------
        image_data
            an array representing the image to use to create the ImageData object.
        image_color
            a constant representing the color scheme of the image.
        image_title
            a title for the image.
        image_capture_time
            a time stamp marking when the image was captured.
        segmentation_initialization_mask
            the mask used to initialize the segmentation of the image stored in this object.
            This is not used in all types of image filters.
        image_data_msg
            an image_data ros message object.
        image_data_location
            a string representing the filepath to a saved image data object.
        """

        # Define error behaviour for all cases
        self.display_error_messages = display_error_messages

        # Define an empty initialized segmentation mask in case none is given later
        self.segmentation_initialization_mask = array([])

        # Define attributes that may be filled in later
        self.ds_image_size_x = 0
        self.ds_image_size_y = 0
        self.down_sampling_rate = 0
        self.image_crop_coordinates = []

        # --------------------------------------------------------------
        # Create empty parameters for use by the filters
        # !!! Order of parameters represent order of operations expected
        # --------------------------------------------------------------
        self.original_image = array([])
        self.cropped_image = None
        self.colorized_image = None
        self.down_sampled_image = None
        self.pre_processed_image = None
        self.image_mask = None
        self.post_processed_mask = None
        self.sure_foreground_mask = None
        self.sure_background_mask = None
        self.probable_foreground_mask = None

        # If the image data object is being created from an image_data message object
        if image_data_msg is not None:

            # Fill in the object properties from the message fields
            self.bridge_image_data_and_message(TO_OBJECT, message=image_data_msg)

        # If the image data object is being created from an image data string
        elif image_data_location is not None:

            # Fill in the object properties from the string
            self.build_object_from_files(image_data_location)

        # Otherwise
        else:

            # Check that an image has been given for object creation
            if image_data is None:
                raise Exception("An ImageData object could not be created because an image was not provided.")

            # Save the mask used to initialize the segmentation of this image
            if segmentation_initialization_mask is not None:
                self.segmentation_initialization_mask = segmentation_initialization_mask

            # Save the image given
            self.original_image = image_data

            # Save the time the image was taken or save the current time
            if image_capture_time is not None:
                self.image_capture_time = image_capture_time
            else:
                self.image_capture_time = Time.now()

            # Define basic parameters of the image
            self.image_title = image_title
            self.image_color = image_color

            # Create empty parameters for storing the centroids and contours
            self.contours_in_image = []
            self.contour_centroids = []

        # Calculate the size of the image regardless of how the object is created
        self.image_size_x = self.original_image.shape[1]
        self.image_size_y = self.original_image.shape[0]

    def convert_to_message(self):
        """
        Converts the existing data object into an equivalent ROS message.
        """

        return self.bridge_image_data_and_message(TO_MESSAGE)

    def generate_contours_in_image(self):
        """
        Generate contours from the 2-dimensional binary image stored in the expanded_image_mask field. Stores the
        result in the contours_in_image field of the current object.
        """

        # Define an empty list to store the result
        self.contours_in_image = []

        # Only create the contours if the expanded image mask has been created
        # AND
        # the expanded image mask contains any contours.
        if self.post_processed_mask is not None and not sum(self.post_processed_mask) == 0:

            # Use a built-in function to generate the contours
            contours_in_image, hierarchy = findContours(
                self.post_processed_mask.astype(uint8),
                RETR_EXTERNAL,
                CHAIN_APPROX_NONE
            )

            # Sort the resulting contours by area with the largest contour first
            temp_contours = sorted(contours_in_image,
                                   key=contourArea,
                                   reverse=True)

            # Define a minimum area requirement
            minimum_contour_area = 10

            # Only add contours to the final list that exceed the minimum contour area requirement
            for contour in temp_contours:
                if contourArea(contour) > minimum_contour_area:
                    self.contours_in_image.append(contour)

    def calculate_image_centroids(self):
        """
        Calculate the centroids of each contour in the list of contours. Returns the result as a
        list of (x, y) coordinates.
        """
        if len(self.contours_in_image) > 0:
            # create empty array to return when no centroids are found
            result = []

            # calculate the centroid of each contour
            for contour in self.contours_in_image:
                temp_moments = moments(array(contour))
                temp_centroid_x = int(temp_moments["m10"] / temp_moments["m00"])
                temp_centroid_y = int(temp_moments["m01"] / temp_moments["m00"])
                self.contour_centroids.append((temp_centroid_x, temp_centroid_y))

            # append the centroid of the largest contour found
            result.append((self.contours_in_image[0], self.contour_centroids[0]))

            # if 2 or more contours were found and the second contour also big, include it
            if len(self.contour_centroids) >= 2:
                if (contourArea(self.contours_in_image[1]) >=
                        0.9 * contourArea(self.contours_in_image[0])):
                    result.append((self.contours_in_image[1], self.contour_centroids[1]))

            return result

    def bridge_image_data_and_message(self, direction: int, message: image_data_message = None):
        """
        Convert an image data object into a ROS image data message and vice versa.
        """

        # Fill in the basic image message information
        if direction == TO_MESSAGE:

            # Create a new message object
            message = image_data_message()

            message.image_title = self.image_title
            message.image_color = self.image_color

            message.header.stamp = self.image_capture_time

            message.image_size_x = self.image_size_x
            message.image_size_y = self.image_size_y

            message.ds_image_size_x = self.ds_image_size_x
            message.ds_image_size_y = self.ds_image_size_y

            message.down_sampling_rate = self.down_sampling_rate

            message.image_crop_coordinates = bridge_list_of_points_multi_array(TO_MESSAGE,
                                                                               list_of_points=self.image_crop_coordinates)

            message.contours_in_image = bridge_list_of_contours_multi_array(TO_MESSAGE,
                                                                            list_of_contours=self.contours_in_image)
            message.contour_centroids = bridge_list_of_points_multi_array(TO_MESSAGE,
                                                                          list_of_points=self.contour_centroids)

        # Fill in the basic object information
        elif direction == TO_OBJECT:

            # Check that the proper input is not None
            if message is None:
                raise Exception("message cannot be None when converting to object.")

            self.image_title = message.image_title
            self.image_color = message.image_color

            self.image_capture_time = message.header.stamp

            self.image_size_x = message.image_size_x
            self.image_size_y = message.image_size_y

            self.ds_image_size_x = message.ds_image_size_x
            self.ds_image_size_y = message.ds_image_size_y

            self.down_sampling_rate = message.down_sampling_rate

            self.image_crop_coordinates = bridge_list_of_points_multi_array(TO_OBJECT,
                                                                            array_message=message.image_crop_coordinates)

            self.contours_in_image = bridge_list_of_contours_multi_array(TO_OBJECT,
                                                                         array_message=message.contours_in_image)
            self.contour_centroids = bridge_list_of_points_multi_array(TO_OBJECT,
                                                                       array_message=message.contour_centroids)
        else:
            raise Exception("Invalid direction given.")

        # --------------------------------------------------------------
        # Convert each image field to its corresponding message field OR
        # convert each message field to its corresponding image field.
        # --------------------------------------------------------------

        # Segmentation Initialization Mask
        temp_result = self.convert_single_field(direction=direction, image_field=self.segmentation_initialization_mask,
                                                message_field=message.segmentation_initialization_mask,
                                                error_message="Segmentation Initialization Mask")
        message.segmentation_initialization_mask = temp_result[1]
        self.segmentation_initialization_mask = temp_result[0]

        # Original Image
        temp_result = self.convert_single_field(direction=direction, image_field=self.original_image,
                                                message_field=message.original_image,
                                                error_message="Original Image")
        message.original_image = temp_result[1]
        self.original_image = temp_result[0]

        # Cropped Image
        temp_result = self.convert_single_field(direction=direction, image_field=self.cropped_image,
                                                message_field=message.cropped_image,
                                                error_message="Cropped Image")
        message.cropped_image = temp_result[1]
        self.cropped_image = temp_result[0]

        # Colorized Image
        temp_result = self.convert_single_field(direction=direction, image_field=self.colorized_image,
                                                message_field=message.colorized_image,
                                                error_message="Colorized Image")
        message.colorized_image = temp_result[1]
        self.colorized_image = temp_result[0]

        # Down-sample Image
        temp_result = self.convert_single_field(direction=direction, image_field=self.down_sampled_image,
                                                message_field=message.down_sampled_image,
                                                error_message="Down-sampled Image")
        message.down_sampled_image = temp_result[1]
        self.down_sampled_image = temp_result[0]

        # Pre-process Image
        temp_result = self.convert_single_field(direction=direction, image_field=self.pre_processed_image,
                                                message_field=message.pre_processed_image,
                                                error_message="Pre-processed Image")
        message.pre_processed_image = temp_result[1]
        self.pre_processed_image = temp_result[0]

        # Image Mask
        temp_result = self.convert_single_field(direction=direction, image_field=self.image_mask,
                                                message_field=message.image_mask,
                                                error_message="Image Mask")
        message.image_mask = temp_result[1]
        self.image_mask = temp_result[0]

        # Post-processed Image Mask
        temp_result = self.convert_single_field(direction=direction, image_field=self.post_processed_mask,
                                                message_field=message.post_processed_mask,
                                                error_message="Post-processed Mask")
        message.post_processed_mask = temp_result[1]
        self.post_processed_mask = temp_result[0]

        # Sure Foreground Image Mask
        temp_result = self.convert_single_field(direction=direction, image_field=self.sure_foreground_mask,
                                                message_field=message.sure_foreground_mask,
                                                error_message="Sure Foreground Image Mask")
        message.sure_foreground_mask = temp_result[1]
        self.sure_foreground_mask = temp_result[0]

        # Sure Background Image Mask
        temp_result = self.convert_single_field(direction=direction, image_field=self.sure_background_mask,
                                                message_field=message.sure_background_mask,
                                                error_message="Sure Background Image Mask")
        message.sure_background_mask = temp_result[1]
        self.sure_background_mask = temp_result[0]

        # Probable Foreground Image Mask
        temp_result = self.convert_single_field(direction=direction, image_field=self.probable_foreground_mask,
                                                message_field=message.probable_foreground_mask,
                                                error_message="Probable Foreground Image Mask")
        message.probable_foreground_mask = temp_result[1]
        self.probable_foreground_mask = temp_result[0]

        # Return the resulting message if required
        if direction == TO_MESSAGE:
            return message

    def convert_single_field(self, direction, image_field, message_field, error_message):

        # Create a bridge object to convert the image arrays to image message objects
        bridge = CvBridge()

        try:
            if direction == TO_MESSAGE:
                message_field = Image()
                if image_field is not None:
                    if len(image_field) != 0:
                        message_field = bridge.cv2_to_imgmsg(image_field)
            elif direction == TO_OBJECT:
                image_field = None
                if message_field is not None:
                    if len(message_field.data) != 0:
                        image_field = frombuffer(message_field.data, dtype=uint8)
                        if message_field.encoding == "8UC1":
                            image_field = reshape(image_field, (message_field.height, message_field.width))
                        elif message_field.encoding == "8UC3" or \
                                message_field.encoding == "rgb8" or \
                                message_field.encoding == "bgr8":
                            image_field = reshape(image_field, (message_field.height, message_field.width, 3))
                        else:
                            raise Exception("Unknown encoding given.")
            else:
                raise Exception("Invalid direction given.")
            return image_field, message_field
        except CvBridgeError:
            if self.display_error_messages:
                print(error_message + " could not be converted.")

    def save_object_to_file(self, save_location: str, suffix: str = None) -> str:
        """
        Saves the image data object to the location given. The image data object is saved as a folder containing a text
        file containing all simple data fields and a single numpy array file containing every numpy array.

        Parameters
        ----------
        save_location
            The location of the folder in which to save the data.
        suffix
            A string to append to the end of the folder name.

        Returns
        -------
        str
            The full file path of the compressed folder.
        """

        # Check that the save location exists before any progress is made
        if not exists(save_location):
            raise Exception(save_location + " is not a valid location.")

        # Add a backslash to the save location if it is not already included
        if not save_location[-1] == '/':
            save_location = save_location.join('/')

        # Replace the None value from the suffix if necessary
        if suffix is None:
            suffix = ""

        # Build the file names to use to store the data
        date_prefix = date_stamp_str()
        save_folder_path = save_location + date_prefix + IMAGE_DATA_OBJECT + suffix
        simple_data_file_path = save_folder_path + '/' + date_prefix + SIMPLE_DATA
        array_data_file_path = save_folder_path + '/' + date_prefix + ARRAY_DATA

        # Make the directory in which to store the data
        mkdir(save_folder_path)

        # Save the simple data fields to a text file
        # region

        # Define the variable that will be saved to the text file
        simple_data_string = ""

        # Add the image title
        simple_data_string = create_single_line_simple_data(IMAGE_TITLE, self.image_title, simple_data_string)

        # Add the image color
        simple_data_string = create_single_line_simple_data(IMAGE_COLOR, self.image_color, simple_data_string)

        # Add the image size in x
        simple_data_string = create_single_line_simple_data(IMAGE_SIZE_X, self.image_size_x, simple_data_string)

        # Add the image size in y
        simple_data_string = create_single_line_simple_data(IMAGE_SIZE_Y, self.image_size_y, simple_data_string)

        # Add the down-sampled image size in x
        simple_data_string = create_single_line_simple_data(DS_IMAGE_SIZE_X, self.ds_image_size_x, simple_data_string)

        # Add the down-sampled image size in y
        simple_data_string = create_single_line_simple_data(DS_IMAGE_SIZE_Y, self.ds_image_size_y, simple_data_string)

        # Add the down-sampling rate
        simple_data_string = create_single_line_simple_data(DOWN_SAMPLING_RATE, self.down_sampling_rate,
                                                            simple_data_string)

        # Add the image crop coordinates
        simple_data_string = create_single_line_list_data(IMAGE_CROP_COORDINATES, self.image_crop_coordinates,
                                                          simple_data_string)

        # Add the contours in image
        simple_data_string = create_single_line_list_data(CONTOURS_IN_IMAGE, self.contours_in_image, simple_data_string)

        # Add the centroids in the image
        simple_data_string = create_single_line_list_data(CONTOUR_CENTROIDS, self.contour_centroids, simple_data_string)

        # Add the image capture time
        simple_data_string = create_single_line_time_stamp(IMAGE_CAPTURE_TIME, self.image_capture_time,
                                                           simple_data_string)

        # Write the string to the text file and then save it
        simple_data_file = open(simple_data_file_path + TXT, 'w')
        simple_data_file.write(simple_data_string)
        simple_data_file.close()

        # endregion

        # Save the array fields to a numpy array file
        savez(array_data_file_path,
              segmentation_initialization_mask=self.segmentation_initialization_mask,
              original_image=self.original_image,
              cropped_image=self.cropped_image,
              colorized_image=self.colorized_image,
              down_sampled_image=self.down_sampled_image,
              pre_processed_image=self.pre_processed_image,
              image_mask=self.image_mask,
              post_processed_mask=self.post_processed_mask,
              sure_foreground_mask=self.sure_foreground_mask,
              sure_background_mask=self.sure_background_mask,
              probable_foreground_mask=self.probable_foreground_mask
              )

        # Return the location where the data was saved
        return save_folder_path

    def build_object_from_files(self, object_file_location: str):
        """
        Builds the image data object using the data stored in the given file location. The image data object must have
        been saved as a folder containing a text file and a single numpy array file.

        Parameters
        ----------
        object_file_location
            The location of the folder in which the image object was saved.
        """

        # Check that the given location exists before any progress is made
        if not exists(object_file_location):
            raise Exception(object_file_location + " is not a valid location.")

        # Add a backslash to the object file location if it is not already included
        if not object_file_location[-1] == '/':
            object_file_location = object_file_location + '/'

        # Get the name of every file in the object file location
        file_names = listdir(object_file_location)

        # Define default values for the file paths so that they can be checked later
        simple_data_file_path = ""
        array_data_file_path = ""

        # Find the path to the simple data and the array data files
        for file_name in file_names:
            if SIMPLE_DATA in file_name and TXT in file_name:
                simple_data_file_path = object_file_location + file_name
            elif ARRAY_DATA in file_name and NPZ in file_name:
                array_data_file_path = object_file_location + file_name
            else:
                raise Exception(file_name + " was unexpectedly found in the folder.")

        # Check that each file was found
        if not len(simple_data_file_path) > 0:
            raise Exception("The file path for the simple data file was not found.")
        if not exists(simple_data_file_path):
            raise Exception(simple_data_file_path + " is not a valid file path.")
        if not len(array_data_file_path) > 0:
            raise Exception("The file path for the array data file was not found.")
        if not exists(array_data_file_path):
            raise Exception(array_data_file_path + " is not a valid file path.")

        # Open the simple data file and read each line from it
        simple_data_file = open(simple_data_file_path, 'r')
        all_data_line = simple_data_file.read()

        # Remove the carriage return character at the end of the string
        all_data_line = all_data_line[:-len(NEW_LINE)]

        # Pull each field from the string by splitting on the carriage returns
        simple_data_lines = all_data_line.split(NEW_LINE)

        # Rebuild the data contained within each line of the text file
        for single_line_data in simple_data_lines:

            # Rebuild the data from the line
            field_name, value = rebuild_data(single_line_data)

            # Place the rebuilt data into the corresponding object attribute
            if field_name == IMAGE_TITLE:
                self.image_title = value
            elif field_name == IMAGE_COLOR:
                self.image_color = value
            elif field_name == IMAGE_SIZE_X:
                self.image_size_x = value
            elif field_name == IMAGE_SIZE_Y:
                self.image_size_y = value
            elif field_name == DS_IMAGE_SIZE_X:
                self.ds_image_size_x = value
            elif field_name == DS_IMAGE_SIZE_Y:
                self.ds_image_size_y = value
            elif field_name == DOWN_SAMPLING_RATE:
                self.down_sampling_rate = value
            elif field_name == IMAGE_CROP_COORDINATES:
                self.image_crop_coordinates = value
            elif field_name == CONTOURS_IN_IMAGE:
                self.contours_in_image = value
            elif field_name == CONTOUR_CENTROIDS:
                self.contour_centroids = value
            elif field_name == IMAGE_CAPTURE_TIME:
                self.image_capture_time = value
            else:
                raise Exception(field_name + " is not a known attribute.")

        # Load the numpy arrays contained in the array data file
        arrays = load(array_data_file_path)

        # Fill in each field from the corresponding array
        self.segmentation_initialization_mask = arrays[SEGMENTATION_INITIALIZATION_MASK]
        self.original_image = arrays[ORIGINAL_IMAGE]
        self.cropped_image = arrays[CROPPED_IMAGE]
        self.colorized_image = arrays[COLORIZED_IMAGE]
        self.down_sampled_image = arrays[DOWN_SAMPLED_IMAGE]
        self.pre_processed_image = arrays[PRE_PROCESSED_IMAGE]
        self.image_mask = arrays[IMAGE_MASK]
        self.post_processed_mask = arrays[POST_PROCESSED_MASK]
        self.sure_foreground_mask = arrays[SURE_FOREGROUND_MASK]
        self.sure_background_mask = arrays[SURE_BACKGROUND_MASK]
        self.probable_foreground_mask = arrays[PROBABLE_FOREGROUND_MASK]
