"""
Contains code for ImageData class.
"""

# Import standard libraries
import cv2
from numpy import sum, uint8, array
from cv_bridge import CvBridge, CvBridgeError
from thyroid_ultrasound_imaging.msg import image_data_message

# Import custom functions and constants
from thyroid_ultrasound_imaging_support.ImageData.BridgeImageDataMessageConstants import *
from thyroid_ultrasound_imaging_support.ImageData.bridge_list_of_points_multi_array import \
    bridge_list_of_points_multi_array
from thyroid_ultrasound_imaging_support.ImageData.bridge_list_of_contours_multi_array import \
    bridge_list_of_contours_multi_array


class ImageData:
    """
    A class for holding image data and its filtered components.

    Attributes:
        image_title
            A title to display for the image
        image_color
            The color coding of the image according to custom constants

        image_size_x
            The original image size in the x direction
        image_size_y
            The original image size in the y direction

        segmentation_initialization_mask
            The mask to use to initialize the segmentation of the image.

        original_image
            The original image
        cropped_image
            The cropped version of the original image
        colorized_image
            The recolored version of the cropped image
        pre_processed_image
            The pre-processed version of the colorized image
        image_mask
            The binary mask generated by segmenting the pre-processed image
        expanded_image_mask
            The binary mask generated by expanding the image_mask to the original image size
        sure_foreground_mask
            The binary mask generated by shrinking the regions of the expanded image mask
        sure_background_mask
            The binary mask generated by expanding the regions of the image mask and inverting the mask
        probable_foreground_mask
            The binary mask generated as the difference between the sure foreground mask and the sure background mask

        contours_in_image
            A list of contours found in the expanded image mask
        contour_centroids
            A list of centroids of the contours found in the image

    """

    def __init__(self, image_data: array = None,
                 image_filepath: str = None,
                 image_color: int = None,
                 image_title: str = None,
                 image_size_x: int = 0,
                 image_size_y: int = int(0),
                 segmentation_initialization_mask: array = None,
                 image_data_msg: image_data_message = None,
                 display_error_messages: bool = False):
        """
        Creates a new ImageData object.

        Parameters
        ----------
        image_data
            an array representing the image to use to create the ImageData object.
        image_filepath
            a string containing the path to an image file to use to create the ImageData object.
        image_color
            a constant representing the color scheme of the image.
        image_title
            a title for the image.
        image_size_x
            the size of the image in the x-axis.
        image_size_y
            the size of the image in the y-axis.
        segmentation_initialization_mask
            the mask used to initialize the segmentation of the image stored in this object.
            This is not used in all types of image filters.
        image_data_msg
            an image_data ros message object.
        """

        # If the image data object is being created from an image_data message object
        if image_data_msg is not None:

            # Fill in the object properties from the message fields
            self.bridge_image_data_and_message(TO_OBJECT, message=image_data_msg)

            # # Read the color of the image from the message
            # self.image_color = image_data_msg.image_color
            #
            # # Create a temporary bridge object to decode the image messages
            # temp_bridge = CvBridge()
            #
            # # Decode the image messages
            # try:
            #     self.segmentation_initialization_mask = temp_bridge.imgmsg_to_cv2(
            #         image_data.segmentation_initialization_mask,
            #         desired_encoding='passthrough'
            #     )
            #
            #     self.original_image = temp_bridge.imgmsg_to_cv2(
            #         image_data.original_image,
            #         desired_encoding='passthrough'
            #     )
            #
            #     self.cropped_image = temp_bridge.imgmsg_to_cv2(
            #         image_data.cropped_image,
            #         desired_encoding='passthrough'
            #     )
            #
            #     self.colorized_image = temp_bridge.imgmsg_to_cv2(
            #         image_data.colorized_image,
            #         desired_encoding='passthrough'
            #     )
            #
            # except CvBridgeError:
            #     print("Image could not be decoded.")

        # Otherwise
        else:

            # Check that an image has been given for object creation
            if image_data is None and image_filepath is None:
                raise Exception("An ImageData object could not be created because an image was not provided.")

            # Define basic parameters of the image
            self.image_color = image_color

            # Save the mask used to initialize the segmentation of this image
            self.segmentation_initialization_mask = segmentation_initialization_mask

            # --------------------------------------------------------------
            # Save the data for the image according to how it has been given
            # --------------------------------------------------------------

            # If the image is only given as a filepath, read the image from the file
            if image_filepath is not None and image_data is None:
                self.original_image = cv2.imread(image_filepath)

            # Else if the image is given as an array, save the array
            elif image_data is not None:
                self.original_image = image_data

            # Otherwise initialize an empty object
            else:
                self.original_image = None

            # --------------------------------------------------------------
            # Create empty parameters for use by the filters
            # !!! Order of parameters represent order of operations expected
            # --------------------------------------------------------------
            self.cropped_image = None
            self.colorized_image = None

        # --------------------------------------------------------------

        # Define basic parameters of the image
        self.image_title = image_title
        self.display_error_messages = display_error_messages

        # Calculate the size of the image if one is given
        if self.original_image is not None:
            self.image_size_x = self.original_image.shape[1]
            self.image_size_y = self.original_image.shape[0]

        # Otherwise set it to a default value
        else:
            self.image_size_x = image_size_x
            self.image_size_y = image_size_y

        # --------------------------------------------------------------
        # Create empty parameters for use by the filters
        # !!! Order of parameters represent order of operations expected
        # --------------------------------------------------------------
        self.pre_processed_image = None
        self.image_mask = None
        self.expanded_image_mask = None
        self.sure_foreground_mask = None
        self.sure_background_mask = None
        self.probable_foreground_mask = None

        # Create empty parameters for storing the centroids and contours
        self.contours_in_image = None
        self.contour_centroids = []

    def generate_contours_in_image(self):
        """
        Generate contours from the 2-dimensional binary image stored in the expanded_image_mask field. Stores the
        result in the contours_in_image field of the current object.
        """

        # Define an empty list to store the result
        self.contours_in_image = []

        # Only create the contours if the expanded image mask has been created
        # AND
        # the expanded image mask contains any contours.
        if self.expanded_image_mask is not None and not sum(self.expanded_image_mask) == 0:

            # Use a built-in function to generate the contours
            contours_in_image, hierarchy = cv2.findContours(
                self.expanded_image_mask.astype(uint8),
                cv2.RETR_EXTERNAL,
                cv2.CHAIN_APPROX_NONE
            )

            # Sort the resulting contours by area with the largest contour first
            temp_contours = sorted(contours_in_image,
                                   key=cv2.contourArea,
                                   reverse=True)

            # Define a minimum area requirement
            minimum_contour_area = 10

            # Only add contours to the final list that exceed the minimum contour area requirement
            for contour in temp_contours:
                if cv2.contourArea(contour) > minimum_contour_area:
                    self.contours_in_image.append(contour)

    def calculate_image_centroids(self):
        """
        Calculate the centroids of each contour in the list of contours. Returns the result as a
        list of (x, y) coordinates.
        """

        # create empty array to return when no centroids are found
        result = []

        # calculate the centroid of each contour
        for contour in self.contours_in_image:
            temp_moments = cv2.moments(contour)
            temp_centroid_x = int(temp_moments["m10"] / temp_moments["m00"])
            temp_centroid_y = int(temp_moments["m01"] / temp_moments["m00"])
            self.contour_centroids.append((temp_centroid_x, temp_centroid_y))

        # append the centroid of the largest contour found
        result.append((self.contours_in_image[0], self.contour_centroids[0]))

        # if 2 or more contours were found and the second contour also big, include it
        if len(self.contour_centroids) >= 2:
            if (cv2.contourArea(self.contours_in_image[1]) >=
                    0.9 * cv2.contourArea(self.contours_in_image[0])):
                result.append((self.contours_in_image[1], self.contour_centroids[1]))

        return result

    def bridge_image_data_and_message(self, direction: int, message: image_data_message = None):
        """
        Convert an image data object into a ROS image data message and vice versa.
        """

        # Fill in the basic image message information
        if direction == TO_MESSAGE:

            # Create a new message object
            message = image_data_message()

            message.image_title = self.image_title
            message.image_color = self.image_color

            message.image_size_x = self.image_size_x
            message.image_size_y = self.image_size_y

            message.contours_in_image = bridge_list_of_contours_multi_array(TO_MESSAGE,
                                                                            list_of_contours=self.contours_in_image)
            message.contour_centroids = bridge_list_of_points_multi_array(TO_MESSAGE,
                                                                          list_of_points=self.contour_centroids)

        # Fill in the basic object information
        elif direction == TO_OBJECT:

            # Check that the proper input is not None
            if message is None:
                raise Exception("message cannot be None when converting to object.")

            self.image_title = message.image_title
            self.image_color = message.image_color

            self.image_size_x = message.image_size_x
            self.image_size_y = message.image_size_y

            self.contours_in_image = bridge_list_of_contours_multi_array(TO_OBJECT,
                                                                         list_of_contours=message.contours_in_image)
            self.contour_centroids = bridge_list_of_points_multi_array(TO_OBJECT,
                                                                       list_of_points=message.contour_centroids)
        else:
            raise Exception("Invalid direction given.")

        # Create a bridge object to convert the image arrays to image message objects
        bridge = CvBridge()

        # Create a list of images to include
        image_fields = [self.segmentation_initialization_mask,
                        self.original_image,
                        self.cropped_image,
                        self.colorized_image,
                        self.pre_processed_image,
                        self.image_mask,
                        self.expanded_image_mask,
                        self.sure_foreground_mask,
                        self.sure_background_mask,
                        self.probable_foreground_mask]

        # Create a list of message fields to fill
        message_fields = [message.segmentation_initialization_mask,
                          message.original_image,
                          message.cropped_image,
                          message.colorized_image,
                          message.pre_processed_image,
                          message.image_mask,
                          message.expanded_image_mask,
                          message.sure_foreground_mask,
                          message.sure_background_mask,
                          message.probable_foreground_mask]

        # Create a list of image titles to include in the error messages
        error_messages = ["Segmentation initialization mask",
                          "Original image",
                          "Cropped image",
                          "Colorized image",
                          "Pre-processed image",
                          "Image mask",
                          "Expanded image mask",
                          "Sure foreground mask",
                          "Sure background mask",
                          "Probable foreground mask"]

        # Convert each image field to its corresponding message field OR
        # convert each message field to its corresponding image field,
        # otherwise display the corresponding error message
        for image_field, message_field, error_message in \
                zip(image_fields, message_fields, error_messages):
            try:
                if direction == TO_MESSAGE:
                    if image_field is not None:
                        message_field = bridge.cv2_to_imgmsg(image_field)
                elif direction == TO_OBJECT:
                    if message_field is not None:
                        image_field = bridge.imgmsg_to_cv2(message_field)
                else:
                    raise Exception("Invalid direction given.")
            except CvBridgeError:
                if self.display_error_messages:
                    print(error_message + " could not be converted.")

        # Return the resulting message if required
        if direction == TO_MESSAGE:
            return message



