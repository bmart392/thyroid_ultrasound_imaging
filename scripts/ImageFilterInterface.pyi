import abc

import numpy as np

from ImageData import *
import FilterConstants as FC

class ImageFilterInterface(metaclass=abc.ABCMeta):


    @abc.abstractmethod(property)
    def __init__(self):
        self.filter_color = None
        self.image_crop_included = None
        self.image_crop_coordinates = None

    @classmethod
    def __subclasshook__(cls, subclass):
        return (hasattr(subclass, 'filter_color') and
                hasattr(subclass, 'original_image_color') and
                hasattr(subclass, 'image_crop_included') and
                hasattr(subclass, 'image_crop_coordinates') and
                hasattr(subclass, 'debug_mode') and
                hasattr(subclass, 'analysis_mode') and
                callable('fully_filter_image'))

    @abc.abstractmethod
    def fully_filter_image(self, image_data: ImageData) -> ImageData:
        """
            Fully filter the passed image data.
        """
        return NotImplementedError

    def colorize_image(self, image_data: ImageData) -> ImageData:
        """
            Recolor the image based on the filter color of the image filter.

            Parameters
            ----------
            image_data: ImageData
                the image data object containing the image to be recolored.
        """

        # recolor the image if the image is not in the desired color for the filter
        if not self.filter_color == image_data.image_color:

            # set the colorized image based on the color required by the filter
            image_data.colorized_image = cv2.cvtColor(image_data.get_original_image(), self.filter_color)

        # otherwise set the colorized image as the original image
        else:
            image_data.colorized_image = image_data.original_image

        # return the image data object
        return image_data

    def crop_image(self, image_data: ImageData) -> ImageData:
        """
            Crop the original image based on the needs of the color filter.

            Parameters
            ----------
            image_data: ImageData
                the image data object containing the image to be cropped.
        """

        # If the image needs to be cropped
        if self.image_crop_included:

            # Define the x and y values of the crop region
            crop_x_0 = self.image_crop_coordinates[0][0]
            crop_y_0 = self.image_crop_coordinates[0][1]
            crop_x_1 = self.image_crop_coordinates[1][0]
            crop_y_1 = self.image_crop_coordinates[1][1]

            # check that the image has the correct shape, then crop it
            if image_data.original_image.ndim > 3 or image_data.original_image.ndim < 2:
                raise Exception("The dimensions of the original image are invalid.")
            elif image_data.original_image.ndim == 3:
               image_data.cropped_image = image_data.original_image[:, crop_y_0:crop_y_1, crop_x_0:crop_x_1]
            else:
                image_data.cropped_image = image_data.original_image[crop_y_0:crop_y_1, crop_x_0:crop_x_1]

        # Otherwise pass the original image on
        else:
            image_data.cropped_image = image_data.original_image

        # Return the modified image_data
        return image_data

    def expand_image_mask(self, image_data: ImageData) -> ImageData:
        """
            Expand the image mask generated by the filter to the full size of the image, if necessary.

            Parameters
            ----------
            image_data: ImageData
                the image data object containing the image to be expanded.
        """

        # Expand the mask if it is not the same size as the original image
        if not image_data.original_image.shape == image_data.image_mask.shape:

            # Create an empty image mask
            image_data.expanded_image_mask = np.zeros(image_data.original_image.shape)

            # Copy the smaller mask data on to the original data
            for row in range(image_data.image_mask.shape[0]):
                for column in range(image_data.image_mask.shape[1]):
                    image_data.expanded_image_mask[row + self.image_crop_coordinates[0][1],
                                                   column + self.image_crop_coordinates[0][0]] = (
                        image_data.image_mask[row, column]
                    )

        # Else copy the image mask to the expanded mask
        else:
            image_data.expanded_image_mask = image_data.image_mask

        # Return the updated image data object
        return image_data